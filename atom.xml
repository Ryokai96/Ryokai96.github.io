<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ryokai 的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ryokai.xyz/"/>
  <updated>2018-03-14T12:32:10.000Z</updated>
  <id>https://blog.ryokai.xyz/</id>
  
  <author>
    <name>Ryokai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java调用静态方法需要类装载还是初始化?</title>
    <link href="https://blog.ryokai.xyz/Java%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E7%B1%BB%E8%A3%85%E8%BD%BD%E8%BF%98%E6%98%AF%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://blog.ryokai.xyz/Java%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E7%B1%BB%E8%A3%85%E8%BD%BD%E8%BF%98%E6%98%AF%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2018-03-14T12:32:10.000Z</published>
    <updated>2018-03-14T12:32:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结论及原因"><a href="#结论及原因" class="headerlink" title="结论及原因"></a>结论及原因</h3><ul><li>结论：Java调用静态方法时会对类进行装载、连接和初始化</li><li>原因：Java类的加载方式是按需加载，遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。<a id="more"></a></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>参照之前写的<a href="https://blog.ryokai.xyz/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA">一篇文章</a>，得出的测试思路：<ul><li>对一个有静态方法和静态代码块的类只进行装载，不进行初始化</li><li>通过反射获取其静态方法，并invoke这个静态方法</li><li>因为静态代码块在初始化的时候执行，所以如果invoke这个静态方法的时候，静态代码块执行了，说明了Java调用静态方法时已经完成了类的初始化</li></ul></li></ul><ul><li>有一个含有static方法和static块的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyStatic() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Test() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"MyStatic"</span>, <span class="keyword">false</span>, test.getClass().getClassLoader());</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">"say"</span>);</span><br><span class="line">            method.invoke(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>控制台打印的结果：</p><blockquote><p>静态代码块执行了</p><p>静态方法执行了</p></blockquote></li></ul><p>以上</p>]]></content>
    
    <summary type="html">
    
      Java调用静态方法需要类装载还是初始化，例子证明
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ryokai.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS7上搭建ZooKeeper+Dubbo分布式服务</title>
    <link href="https://blog.ryokai.xyz/%E5%9C%A8CentOS7%E4%B8%8A%E6%90%AD%E5%BB%BAZooKeeper-Dubbo%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/"/>
    <id>https://blog.ryokai.xyz/%E5%9C%A8CentOS7%E4%B8%8A%E6%90%AD%E5%BB%BAZooKeeper-Dubbo%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/</id>
    <published>2018-01-21T12:20:05.000Z</published>
    <updated>2018-01-21T12:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>系统: CentOS 7.3 x64</li><li>JDK: JDK1.8 8u161</li><li>Ant: apache-ant-1.10.1</li><li>Maven: apache-maven-3.5.2</li><li>Tomcat: apache-tomcat-8.5.24</li><li>ZooKeeper: zookeeper 3.4.11</li></ul><a id="more"></a><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="安装ZooKeeper"><a href="#安装ZooKeeper" class="headerlink" title="安装ZooKeeper"></a>安装ZooKeeper</h3><ol><li><p>解压zookeeper-3.4.11.tar.gz，移动到/opt目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf zookeeper-3.4.11.tar.gz</span><br><span class="line">mv zookeeper-3.4.11 /opt/</span><br></pre></td></tr></table></figure></li><li><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/zookeeper-3.4.11/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">vim zoo.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换下面内容</span></span><br><span class="line">dataDir=/tmp/zookeeper/data</span><br><span class="line">dataLogDir=/tmp/zookeeper/logs</span><br></pre></td></tr></table></figure></li><li><p>创建zookeeper数据和日志目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">mkdir zookeeper</span><br><span class="line">cd zookeeper</span><br><span class="line">mkdir data logs</span><br></pre></td></tr></table></figure></li><li><p>启动zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/zookeeper-3.4.11/bin</span><br><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure></li><li><p>下面是打包成rpm包安装方式，血泪史，可以不看跳过</p><p>下载必要的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y rpm-build rpmdevtools mock</span><br></pre></td></tr></table></figure><p>下载<a href="https://github.com/skottler/zookeeper-rpms">zookeeper-rpms</a>: zookeeper-rpms包含了用于zookeeper构建RPM所需的一切，注意: 应下载用于zookeeper3.4.10的commit也就是58c775d这个commit，3.4.11的版本用这个仓库在centos7上有问题，暂未找到解决方法</p><p>然后按照说明进行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd zookeeper-rpms</span><br><span class="line">rpmdev-setuptree</span><br><span class="line">spectool -g zookeeper.spec</span><br><span class="line">rpmbuild -bs --nodeps --define "_sourcedir $(pwd)" --define "_srcrpmdir $(pwd)" zookeeper.spec</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里直接执行sudo mock zookeeper-3.4.10-1.src.rpm会失败，在zookeeper-rpms的Issues中找到解决方法，输入如下命令即可</span></span><br><span class="line">sudo mock -r epel-7-x86_64 --old-chroot zookeeper-3.4.10-1.src.rpm</span><br></pre></td></tr></table></figure><p> 打包好的文件在/var/lib/mock/epel-7-x86_64/result中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/mock/epel-7-x86_64/result</span><br><span class="line">yum localinstall zookeeper-3.4.10-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p>然后就可以输入命令启动zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper start</span><br></pre></td></tr></table></figure></li></ol><p>   下面是自行打包rpm，最后失败告终，血泪史中的血泪史</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zookeeper-3.4.11中包含的README_packaging.txt中所说，打包成rpm需要先安装cppunit和python-setuptools</span></span><br><span class="line">yum install cppunit</span><br><span class="line">yum install python-setuptools</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后执行</span></span><br><span class="line">ant rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 报错，在一个java文件中import了一个包，这个包找不到，包名忘了，谷歌无果，遂放弃zookeeper-3.4.11，下载zookeeper-3.4.10</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后执行</span></span><br><span class="line">ant rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样报错，但不是一样的错误，好在能在谷歌上搜到出错原因，就是打包rpm还要依赖其他软件包，于是安装，安装后ant继续报错，继续谷歌，发现全是缺乏依赖的软件包，然后就报错-&gt;装软件-&gt;ant-&gt;报错-&gt;...循环，最后安装的软件列表如下</span></span><br><span class="line">gcc</span><br><span class="line">gcc-g++</span><br><span class="line">autoconf</span><br><span class="line">automake</span><br><span class="line">autogen</span><br><span class="line">cppunit-devel</span><br><span class="line">libtool</span><br><span class="line">python-devel</span><br><span class="line">rpm-build</span><br><span class="line">rpmdevtools</span><br><span class="line">mock</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后还是报错，报文件找不到，放弃，谷歌寻找ZooKeeper打包rpm的方法，最后找到了https://github.com/skottler/zookeeper-rpms</span></span><br></pre></td></tr></table></figure><h2 id="运行dubbo-admin"><a href="#运行dubbo-admin" class="headerlink" title="运行dubbo-admin"></a>运行dubbo-admin</h2><ol><li><p>解压dubbo-2.5.9.tar.gz，移动至/opt目录(我习惯放在/opt目录)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf dubbo-2.5.9.tar.gz</span><br><span class="line">mv dubbo-dubbo-2.5.9 /opt</span><br></pre></td></tr></table></figure></li><li><p>在dubbo项目根目录，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install -Dmaven.skip.test</span><br></pre></td></tr></table></figure></li><li><p>上一步执行后，会在dubbo-admin/target下生成war包，将其移动至tomcat目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在tomcat目录下新建dubbo-admin目录</span></span><br><span class="line">cd /opt/apache-tomcat-8.5.24/</span><br><span class="line">mkdir dubbo-admin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将之前生成的war包移动到这里</span></span><br><span class="line">mv /opt/dubbo-dubbo-2.5.9/dubbo-admin/target/dubbo-admin-2.5.9.war ./</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压，指定解压后的目录名为ROOT</span></span><br><span class="line">unzip dubbo-admin-2.5.9.war -d ROOT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以把war包删了</span></span><br><span class="line">rm -f dubbo-admin-2.5.9.war</span><br></pre></td></tr></table></figure></li><li><p>编辑dubbo-admin的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ROOT/WEB-INF/</span><br><span class="line">vim dubbo.properties</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里可以配置dubbo注册中心的类型及地址，dubbo的root用户和guest用户的密码</span></span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">dubbo.admin.root.password=root</span><br><span class="line">dubbo.admin.guest.password=guest</span><br></pre></td></tr></table></figure></li><li><p>编辑tomcat配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/apache-tomcat-8.5.24/conf</span><br><span class="line">vim server.xml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在&lt;server&gt;&lt;/server&gt;中添加一个Service节点</span></span><br><span class="line">&lt;Service name="dubbo-admin"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Connector port="8081" protocol="HTTP/1.1"</span><br><span class="line">               connectionTimeout="20000"</span><br><span class="line">               redirectPort="8443" /&gt;</span><br><span class="line">    &lt;Connector port="8010" protocol="AJP/1.3" redirectPort="8445" /&gt;</span><br><span class="line">    &lt;Engine name="Catalina" defaultHost="localhost"&gt;</span><br><span class="line">      &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;</span><br><span class="line">        &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"</span><br><span class="line">               resourceName="UserDatabase"/&gt;</span><br><span class="line">      &lt;/Realm&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Host name="localhost"  appBase="dubbo-admin"</span><br><span class="line">            unpackWARs="true" autoDeploy="true"&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"</span><br><span class="line">               prefix="localhost_access_log" suffix=".txt"</span><br><span class="line">               pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">&lt;/Engine&gt;</span><br><span class="line">&lt;/Service&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动tomcat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/apache-tomcat-8.5.24/bin/startup.sh</span><br></pre></td></tr></table></figure></li><li><p>开放8081端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我使用的防火墙是firewalld，用iptables的自行网上搜开放端口的方法</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经开放的端口</span></span><br><span class="line">firewall-cmd --list-ports </span><br><span class="line"><span class="meta">#</span><span class="bash"> 若没有8081端口，开放它</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8081/tcp --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经开放的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure></li><li><p>浏览器访问ip:8081即可看见Dubbo Admin页面</p></li></ol>]]></content>
    
    <summary type="html">
    
      在CentOS7上搭建ZooKeeper+Dubbo分布式服务
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Dubbo" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/Dubbo/"/>
    
    
      <category term="ZooKeeper" scheme="https://blog.ryokai.xyz/tags/ZooKeeper/"/>
    
      <category term="Dubbo" scheme="https://blog.ryokai.xyz/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式小结</title>
    <link href="https://blog.ryokai.xyz/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93/"/>
    <id>https://blog.ryokai.xyz/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93/</id>
    <published>2017-08-18T03:15:27.000Z</published>
    <updated>2017-08-18T03:15:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>如果由一个类User，其中有一个方法add()，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"add..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要对add()方法扩展功能，比如在输出”add…”之前，先输出一句”before…”，在输出”add…”之后输出一句”after…”，那么就需要修改add()方法，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"add..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"after..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是直接对add()方法进行修改，不利于系统维护，也容易产生代码的重复。比如在add()以及许多方法中，需要添加记录日志的功能，则需要在这些方法中写记录日志功能的逻辑，或者调用记录日志功能的方法，这会产生很多重复的代码，不利于模块的重用。<a id="more"></a></p><h3 id="问题的解决方案"><a href="#问题的解决方案" class="headerlink" title="问题的解决方案"></a>问题的解决方案</h3><p>为了解决如上问题，最早使用的方案是<strong>纵向继承机制</strong></p><h4 id="纵向继承机制"><a href="#纵向继承机制" class="headerlink" title="纵向继承机制"></a>纵向继承机制</h4><p>纵向继承机制即继承于一个类，从而在方法中调用父类的方法，实现功能扩展，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">  <span class="comment">//记录日志的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用父类方法，实现功能扩展</span></span><br><span class="line">    <span class="keyword">super</span>.writeLog();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种做法也有弊端，并不能根本上解决问题，比如对BaseUser类中的writeLog()方法进行修改，将其改名位recordLog()或添加参数，则User类中的add()方法也要进行修改。这样也是不利于维护的。</p><h4 id="横向抽取机制-代理模式"><a href="#横向抽取机制-代理模式" class="headerlink" title="横向抽取机制(代理模式)"></a>横向抽取机制(代理模式)</h4><p>为了从根本上解决问题，出现了代理模式，代理模式即为委托类创建代理类，通过代理类可以调用委托类的部分功能，并添加一些额外的业务处理。代理模式分为<strong>静态代理</strong>和<strong>动态代理</strong></p><ul><li><p>静态代理: 自己手动创建代理类，代理类在编译期间就已经确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl</span> <span class="keyword">implements</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"add..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoProxy</span> <span class="keyword">implements</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> DaoImpl daoImpl;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DaoProxy</span><span class="params">(DaoImpl daoImpl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.daoImpl = dapImpl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"beagin"</span>);</span><br><span class="line">    daoImpl.add();</span><br><span class="line">    System.out.println(<span class="string">"after"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DaoImpl daoImpl = <span class="keyword">new</span> DaoImpl();</span><br><span class="line">    DaoProxy daoProxy = <span class="keyword">new</span> DaoProxy(daoImpl);</span><br><span class="line">    daoProxy.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理: 代理类不是由自己编写，而是在运行时期生成，下面详细介绍动态代理</p></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理分为jdk动态代理和cglib动态代理，Spring的AOP动态代理就是通过这两者实现的</p><h4 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h4><p>jdk动态代理即使用jdk中提供反射类Proxy和回调接口InvocationHandler实现jdk动态代理，并要求委托类必须实现至少一个接口</p><p>实现步骤:</p><ol><li><p>定义业务逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoImpl</span> <span class="keyword">implements</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"add..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用反射类Proxy和回调接口InvocationHandler实现jdk动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//实现InvocationHandler接口的invoke方法，用于执行目标对象</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before..."</span>);</span><br><span class="line">    Object result = method.invoke(target, args);</span><br><span class="line">    System.out.println(<span class="string">"after..."</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//生成代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义代理类的加载者</span></span><br><span class="line">    ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="comment">//被代理对象实现的接口列表</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">    <span class="comment">//使用Java字节码技术生成代理对象并返回</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(loader, interfaces, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Dao dao = <span class="keyword">new</span> DaoImpl();</span><br><span class="line">    TestInvocationHandler handler = <span class="keyword">new</span> TestInvocationHandler(dao);</span><br><span class="line">    <span class="comment">//daoProxy就是生成的代理对象，它继承于Proxy类，且实现了Dao接口</span></span><br><span class="line">    Dao daoProxy = (Dao) handler.getProxy();</span><br><span class="line">    <span class="comment">//执行add()方法，实际上是执行handler对象的invoke方法，传入的参数分别为当前代理对象，当前执行方法和方法参数</span></span><br><span class="line">    daoProxy.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h4><p>jdk动态代理需要实现类通过接口定义业务方法，对于没有接口的类，jdk毫无办法，这就需要cglib了。</p><ul><li>cglib是一个强大、高性能、高质量的Code生成类库，它封装了asm(Java字节码操控框架)</li><li>cglib通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑</li><li>由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理</li></ul><p>实现步骤:</p><ol><li><p>需要被代理的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"add..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//增强原有方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//前置代理</span></span><br><span class="line">System.out.println(<span class="string">"before..."</span>);</span><br><span class="line"></span><br><span class="line">Object result = proxy.invokeSuper(obj, args);<span class="comment">//调用父类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后置代理</span></span><br><span class="line">System.out.println(<span class="string">"end..."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>产生Dao代理类的工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Dao dao;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">dao = <span class="keyword">new</span> Dao();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dao <span class="title">getDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dao;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取代理类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dao <span class="title">getProxyInstance</span><span class="params">(TestProxy proxy)</span> </span>&#123;</span><br><span class="line">Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">en.setSuperclass(Dao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">en.setCallback(proxy);</span><br><span class="line"><span class="keyword">return</span> (Dao) en.create();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Dao dao = DaoFactory.getProxyInstance(<span class="keyword">new</span> TestProxy());</span><br><span class="line">dao.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Spring中AOP的代理方式"><a href="#Spring中AOP的代理方式" class="headerlink" title="Spring中AOP的代理方式"></a>Spring中AOP的代理方式</h4><ul><li><p>如果目标对象实现了接口，默认情况下会采用jdk动态代理实现AOP</p></li><li><p>如果目标对象实现了接口，可以强制使用cglib动态代理实现AOP</p><ul><li><p>强制使用cglib实现方式:</p><ol><li><p>添加cglib库</p></li><li><p>在Spring配置文件中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>如果目标对象没有实现接口，AOP必须由cglib动态代理实现</p></li><li><p>Spring会自动在jdk动态代理和cglib动态代理之间切换</p></li></ul>]]></content>
    
    <summary type="html">
    
      Java的代理模式的总结
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ryokai.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java静态代码块执行时机</title>
    <link href="https://blog.ryokai.xyz/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"/>
    <id>https://blog.ryokai.xyz/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</id>
    <published>2017-07-04T12:06:24.000Z</published>
    <updated>2017-07-04T12:06:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    百度一下java的static块执行时机，搜出来的文章有两种说法，第一种说static块是在类的加载时执行(包括我看过的Java视频都是这么说的)，另一种则是反对第一种说法，即static块并不是在类的加载时执行的，而是在类的初始化时执行的；谁对谁错，事实用代码证明。<a id="more"></a></p><h3 id="类的运行步骤"><a href="#类的运行步骤" class="headerlink" title="类的运行步骤"></a>类的运行步骤</h3><p>​    类的运行可分为三个步骤：装载、连接、初始化</p><ul><li>装载：查找和导入Class文件</li><li>连接：把类的二进制数据合并到JRE中，又分为三个步骤<ul><li>校验：检查载入Class文件数据的正确性</li><li>准备：给类的静态变量分配存储空间</li><li>解析：将符号引用转成直接引用</li></ul></li><li>初始化：对类的静态变量，静态代码块执行初始化操作(看到这里，结论就已经出来了，但我们还是要用代码来说话)</li></ul><h3 id="用反射机制来证明static块的执行时机"><a href="#用反射机制来证明static块的执行时机" class="headerlink" title="用反射机制来证明static块的执行时机"></a>用反射机制来证明static块的执行时机</h3><ul><li>有一个含static块的类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyStatic() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先来看一个错误的例子(我看的视频里就是用这个例子来证明static块是在类的加载时执行的)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(<span class="string">"MyStatic"</span>);  <span class="comment">//误认为forName方法运行类只完成加载，实际上forName方法运行时已执行了类的初始化</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行结果</p><blockquote><p>静态代码块执行了</p></blockquote><p>​    静态代码块执行了，然而这并不能代表什么，因为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"MyStatic"</span>);</span><br></pre></td></tr></table></figure><p>​    等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"MyStatic"</span>, <span class="keyword">true</span>, test.getClass().getClassLoader());</span><br></pre></td></tr></table></figure><p>​    其中第二个参数指明了是否进行类初始化，将其改成false再试一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Test() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(<span class="string">"MyStatic"</span>, <span class="keyword">false</span>, test.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这时MyStatic类并没有进行初始化过程，而程序运行没有任何输出，得出结论：</p><p>​    <strong>Java中静态代码块是在类的初始化过程中执行的，并不是在类的装载时执行的</strong></p>]]></content>
    
    <summary type="html">
    
      Java的static块执行时机，例子证明
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ryokai.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java双缓冲技术的简单使用</title>
    <link href="https://blog.ryokai.xyz/Java%E5%8F%8C%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.ryokai.xyz/Java%E5%8F%8C%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2017-05-07T08:14:10.000Z</published>
    <updated>2017-05-07T08:14:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    动画的刷新频率越快，那么动画看起来就越连贯。</p><p>​    但是使用java的GUI技术的时候，提高重画频率往往会出现闪烁，移动的物体看起来有点一顿一顿的，原因就是重画频率太快，上个paint方法还没有完成就开始执行下个paint方法了。</p><p>​    要解决这个问题，可以使用java的双缓冲技术。<a id="more"></a></p><h3 id="双缓冲技术原理"><a href="#双缓冲技术原理" class="headerlink" title="双缓冲技术原理"></a>双缓冲技术原理</h3><p>​    每一次调用paint方法之前，先把paint方法需要画出来的东西画在一张虚拟的图片上，画完后再显示在屏幕上</p><ol><li><p>创建个Image对象，用于存放虚拟的图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image offScreenImage = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>重写update方法</p><p>我们知道repaint方法会调用update方法，由update方法来调用paint方法，那么只要重写update方法，就可以对paint方法的调用进行控制</p><p>有关repaint、update和paint之间的关系，可以看这篇文章：<a href="http://blog.csdn.net/xiaoliangmeiny/article/details/6916657">关于Java中的paint，repaint，update三个方法的关系</a></p><p>重写的步骤：</p><ul><li>首先创建一张和整个窗体一样大的图片</li><li>把内容画到图片上</li><li>把图片画到屏幕上</li></ul><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">if</span>(offScreenImage == <span class="keyword">null</span>) &#123;</span><br><span class="line">    offScreenImage = <span class="keyword">this</span>.createImage(WIDTH, HEIGHT);<span class="comment">//创建一张大小和窗口大小一样的虚拟图片</span></span><br><span class="line">  &#125;</span><br><span class="line">  Graphics gOffScreen = offScreenImage.getGraphics();<span class="comment">//获得画笔</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//刷新背景，否则物体运动痕迹会保留</span></span><br><span class="line">  Color c = gOffScreen.getColor();<span class="comment">//复制原前景色</span></span><br><span class="line">  gOffScreen.setColor(backgroundColor);<span class="comment">//backgroundColor为原来设置的背景色</span></span><br><span class="line">  gOffScreen.fillRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT);<span class="comment">//画一个矩形覆盖掉原来的图像</span></span><br><span class="line">  gOffScreen.setColor(c);<span class="comment">//还原前景色</span></span><br><span class="line"></span><br><span class="line">  paint(gOffScreen);<span class="comment">//画到虚拟图片上</span></span><br><span class="line">  g.drawImage(offScreenImage, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);<span class="comment">//把图片画到屏幕上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="双缓冲示例"><a href="#双缓冲示例" class="headerlink" title="双缓冲示例"></a>双缓冲示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ryokai96.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Frame;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.Image;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleBufferTest</span> <span class="keyword">extends</span> <span class="title">Frame</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WIDTH = <span class="number">800</span>;<span class="comment">//窗口宽</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEIGHT = <span class="number">600</span>;<span class="comment">//窗口高</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">50</span>;<span class="comment">//圆的横坐标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">50</span>;<span class="comment">//圆的纵坐标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Image offScreenImage = <span class="keyword">null</span>;<span class="comment">//用于实现双缓冲</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此方法用于创建窗口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">launchFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">setSize(WIDTH, HEIGHT);</span><br><span class="line">setTitle(<span class="string">"DoubleBufferTest"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk1.4之后提供的方法，setLocationRelativeTo(owner);</span></span><br><span class="line"><span class="comment">//这种方法是设定一个窗口的相对于另外一个窗口的位置（一般是居中于父窗口的中间）</span></span><br><span class="line"><span class="comment">//如果owner==null则窗口就居于屏幕的中央。</span></span><br><span class="line">setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使窗口可关闭</span></span><br><span class="line"><span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">setResizable(<span class="keyword">false</span>);<span class="comment">//设置不可改变窗口大小</span></span><br><span class="line"><span class="keyword">this</span>.setBackground(Color.white);</span><br><span class="line"></span><br><span class="line">setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> PaintThread()).start();<span class="comment">//开启repaint线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 重写update方法，实现双缓冲，以消除闪烁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">if</span>(offScreenImage == <span class="keyword">null</span>) &#123;</span><br><span class="line">offScreenImage = <span class="keyword">this</span>.createImage(WIDTH, HEIGHT);<span class="comment">//创建一张大小和窗口大小一样的虚拟图片</span></span><br><span class="line">&#125;</span><br><span class="line">Graphics gOffScreen = offScreenImage.getGraphics();<span class="comment">//获得画笔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//刷新背景，否则物体运动痕迹会保留</span></span><br><span class="line">Color c = gOffScreen.getColor();</span><br><span class="line">gOffScreen.setColor(Color.white);</span><br><span class="line">gOffScreen.fillRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT);</span><br><span class="line">gOffScreen.setColor(c);</span><br><span class="line"></span><br><span class="line">paint(gOffScreen);<span class="comment">//画到虚拟图片上</span></span><br><span class="line">g.drawImage(offScreenImage, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);<span class="comment">//把图片画到屏幕上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Color c = g.getColor();<span class="comment">//取出原前景色</span></span><br><span class="line">g.setColor(Color.RED);<span class="comment">//设置前景色</span></span><br><span class="line">g.fillOval(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="number">30</span>, <span class="number">30</span>);<span class="comment">//画圆</span></span><br><span class="line">g.setColor(c);<span class="comment">//恢复原前景色</span></span><br><span class="line"></span><br><span class="line">y += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用于重画的线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">repaint();<span class="comment">//重画</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">50</span>);<span class="comment">//每隔50ms重画一次</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">DoubleBufferTest tc = <span class="keyword">new</span> DoubleBufferTest();</span><br><span class="line">tc.launchFrame();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java双缓冲技术的原理解释，以及使用Java双缓冲技术的简单使用示例
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ryokai.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于数组名和对数组名取地址</title>
    <link href="https://blog.ryokai.xyz/%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E5%AF%B9%E6%95%B0%E7%BB%84%E5%90%8D%E5%8F%96%E5%9C%B0%E5%9D%80/"/>
    <id>https://blog.ryokai.xyz/%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E5%AF%B9%E6%95%B0%E7%BB%84%E5%90%8D%E5%8F%96%E5%9C%B0%E5%9D%80/</id>
    <published>2017-05-06T09:41:39.000Z</published>
    <updated>2017-05-06T09:41:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下是基于32位系统的测试：</p><ul><li>程序一：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p1 = (<span class="keyword">int</span> *)(&amp;a+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> *p2 = (<span class="keyword">int</span> *)(a+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x, %x"</span>, p1[<span class="number">-1</span>], *p2);<span class="comment">//输出为3, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序二</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n%p\n"</span>, a, &amp;a);<span class="comment">//这里a和&amp;a输出一样为0012FF58</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(&amp;a));<span class="comment">//sizeof(a)输出为12，sizeof(&amp;a)输出为4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n%p"</span>, &amp;a+<span class="number">1</span>, a+<span class="number">1</span>);<span class="comment">//注意&amp;优先级高于+，&amp;a+1输出0012FF64，a+1输出为0012FF5C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序二中：a和&amp;a打印出来的都是数组a的首地址。</p><ul><li>数组名a虽然能够单独拿出来代表一个地址，但是和指针还是有区别的，数组名是符号地址常量，在编译时求值并存在编译器的符号表里面，其值就是个内存地址，程序并没有给其分配空间，这与指针不同，sizeof(a)得到的是整个数组的大小12。所以a与a+0有区别，a+0与&amp;a[0]等价。</li><li>关于&amp;a，注意这里的a是一个指针（a加了&amp;后就自动变成了指针，这点很有趣），指向整个数组，其值是数组的首地址，&amp;a就是指针a取地址，所以sizeof(&amp;a)就是一个指针所占内存空间的大小（可以把int a[3]改为char a[3]试试），而&amp;a+1的偏移量是整个数组的大小，所以，在程序一中p1[-1]输出的不是1而是3。</li><li>关于&amp;a是否非法，本来对常量取地址是非法的，但是标准组织没有规定对数组名取地址是非法还是合法，所以因编译器而异，在VS中是合法的。</li></ul>]]></content>
    
    <summary type="html">
    
      关于数组名和对数组名取地址的示例以及解释
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="C" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/C/"/>
    
    
      <category term="C" scheme="https://blog.ryokai.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo和Github搭建博客</title>
    <link href="https://blog.ryokai.xyz/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://blog.ryokai.xyz/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2017-05-06T01:26:52.000Z</published>
    <updated>2020-01-04T06:35:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇使用GitHub Pages和Hexo搭建独立博客的总结</p><p>我是去年十月份左右接触的git，直到前不久，git对我来说都只是同步个人代码的工具(对git的版本控制、分支都不是很理解)，这次借着搭建博客的机会稍稍理解了一点git的分支是怎么回事</p><p>写博客是一个好习惯，我从去年开始会写一些博客，之后有时间会陆续搬过这里来(其实也就那么几篇- -!)</p><a id="more"></a><p>在看之前，应该先了解一下：</p><ul><li><a href="http://www.jianshu.com/p/242ca1409b00">GitHub</a></li><li><a href="http://www.jianshu.com/p/c6f566021ee0">GitHub Pages</a></li><li><a href="https://hexo.io/zh-cn/">Hexo</a></li><li><a href="http://www.jianshu.com/p/q81RER/">Markdown</a></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="创建对应仓库"><a href="#创建对应仓库" class="headerlink" title="创建对应仓库"></a>创建对应仓库</h3><ol><li>安装Git，略</li><li>注册GitHub，略</li><li>配置Git，略</li><li>与GitHub建立联系，略</li><li>以上4步相关资料：<a href="http://www.open-open.com/lib/view/open1423810370232.html">Git和Github简单配置</a></li><li>在GitHub上创建新的仓库，命名为 username.github.io (其中username为github的用户名)，例如 Ryokai96.github.io</li></ol><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ol><li><p>安装Hexo需要首先安装Node.js，到官网下载安装(最好安装LTS版本)：<a href="https://nodejs.org/en/">Node.js官网</a></p></li><li><p>新建本地文件夹blog</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br></pre></td></tr></table></figure></li><li><p>全局安装hexo-cli，blog文件夹内安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="搭建Hexo博客"><a href="#搭建Hexo博客" class="headerlink" title="搭建Hexo博客"></a>搭建Hexo博客</h2><ol><li><p>创建并初始化Hexo目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init Hexo</span></span><br></pre></td></tr></table></figure><p>完成后，当前目录下会多出一个Hexo目录</p></li><li><p>在Hexo目录中安装需要的插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Hexo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> hexo deploy git插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建hellohexo.md文章</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo new hellohexo.md</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 渲染成静态页面</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo generate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动本地hexo服务器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br></pre></td></tr></table></figure><p>上面两条也可简写为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s</span></span><br></pre></td></tr></table></figure><p>然后在浏览器中输入localhost:4000即可进行预览</p></li><li><p>使用GitHub Pages搭建一个Hexo博客</p><p>编辑Hexo目录下的_config.yml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim _config.yml</span></span><br></pre></td></tr></table></figure><p>将下面这段进行修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span></span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:Ryokai96/Ryokai96.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>注意 : 后面有一个空格，如 type: git</p><p>repository后的url使用ssh形式，注意最后的.git要去掉</p></li><li><p>Hexo首页默认显示最新的一篇文章，可以在文章中使用&lt;!--more--&gt;来分割预览的文章和更多详情，或者使用hexo-excerpt插件来自动分隔（不推荐）。若要使用hexo-exerpt，首先在Hexo目录下安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo 自动截断插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-excerpt --save</span></span><br></pre></td></tr></table></figure><p>然后编辑Hexo目录下的_config.yml文件，添加以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">excerpt:</span></span><br><span class="line">  <span class="attr">depth:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">excerpt_excludes:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">more_excludes:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">hideWholePostExcerpts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>完成部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo generate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy</span></span><br></pre></td></tr></table></figure><p>这两条也可简写为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo d</span></span><br></pre></td></tr></table></figure><p>之后，在浏览器中键入 Ryokai96.github.io 即可访问博客</p></li></ol><h2 id="Hexo的同步"><a href="#Hexo的同步" class="headerlink" title="Hexo的同步"></a>Hexo的同步</h2><p>使用Hexo搭建博客的同学可能会遇到这个问题：如果更换了设备，如何对Hexo博客进行管理？</p><p>github或者gitee都有免费的私有仓库，使用私有仓库同步hexo代码，即可多设备同步hexo配置。</p><ol><li><p>在github或gitee新建一个仓库，名字随便，比如blogcode</p></li><li><p>在blog目录下初始化git仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure></li><li><p>修改.git文件夹下的config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim config</span></span><br></pre></td></tr></table></figure><p>修改config文件，添加以下配置，指定远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[remote "origin"]</span><br><span class="line">        url = git@github.com:Ryokai96/blogcode.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch "master"]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/master</span><br></pre></td></tr></table></figure></li><li><p>如果在新建远程仓库的时候生成了README文件，可以先git pull一下</p></li><li><p>推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"hexo init"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure><p>注意：如果有包含的目录是其他的git仓库，比如git clone方式安装的next主题，在themes/next目录下有.git目录，是无法同步next目录的，这里也不能将其作为子仓库，解决方式有两种，一种是直接删除next目录下的.git目录，另外一种是将next目录下的.git目录以及.git目录中的HEAD文件改名，比如改成.git_backup和HEAD_backup。使用第二种改名的方式可以在当该git仓库有更新时将名字改回来，用git pull更新，这种方式是否有弊端，我还不清楚。</p></li><li><p>之后要更新博客，进入Hexo文件夹，hexo g &amp; hexo d，要同步源文件，就在blog根目录提交修改</p></li><li><p>更换设备后或重装系统后，想管理博客，通过如下步骤：</p><ol><li><p>git clone <a href="mailto:git@github.com">git@github.com</a>:Ryokai96/blogcode.git</p></li><li><p>在克隆过来的本地仓库ryoukai中执行以下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Hexo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><p>然后就可以像原来一样管理博客了</p></li></ol></li></ol><h2 id="Hexo其他配置"><a href="#Hexo其他配置" class="headerlink" title="Hexo其他配置"></a>Hexo其他配置</h2><ul><li>使用Next主题：<a href="http://www.cnblogs.com/syd192/p/6074323.html">Hexo的Next主题配置</a>、<a href="http://theme-next.iissnan.com/getting-started.html">Next使用文档</a></li><li>提交百度谷歌收录：<a href="http://www.jianshu.com/p/8c0707ce5da4">Hexo博客收录百度和谷歌-基于Next主题</a></li><li>让搜索引擎更容易找到你：<a href="http://blog.csdn.net/zaoan_wx/article/details/50859675">Hexo SEO优化</a></li><li>另一个优秀主题Icarus：<a href="https://github.com/ppoffice/hexo-theme-icarus">ppoffice/hexo-theme-icarus</a></li></ul>]]></content>
    
    <summary type="html">
    
      Hexo+GitPages搭建独立博客教程
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Hexo" scheme="https://blog.ryokai.xyz/categories/%E6%8A%80%E6%9C%AF/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://blog.ryokai.xyz/tags/Hexo/"/>
    
  </entry>
  
</feed>
